{% extends "en-us/search/cluster/ClusterGenSearchPage.htm" %}
{%- block htmBodyEndClusterPage %}
{% if resultCount > 0 %}
<wa-details open class="HtmRow" id="observability-dashboard">
  <div slot="summary">
    Observability dashboard for all OpenShift clusters
  </div>
  <div class="wa-stack ">
    <div class="wa-grid ">
      <wa-card with-header>
        <header slot="header" class="wa-heading-m ">Percent of total memory usage for all clusters</header>
        <div id="visualization-cluster-memory-bytes" class=""></div>
      </wa-card>
      <wa-card with-header>
        <header slot="header" class="wa-heading-m ">Percent of total CPU usage for all clusters</header>
        <div id="visualization-cluster-cpu-bytes" class=""></div>
      </wa-card>
    </div>
    <wa-card with-header>
      <header slot="header" class="wa-heading-l ">GPU utilization per cluster</header>
      <div id="visualization-cluster-gpu-utilization" class="wa-grid "></div>
    </wa-card>
    <div class="wa-grid ">
      <div class="wa-stack ">
        <div class="wa-grid ">
          <wa-card with-header>
            <header slot="header" class="wa-heading-m ">Number of GPU nodes for all clusters</header>
            <div id="visualization-cluster-gpu-nodes" class=""></div>
          </wa-card>
          <wa-card with-header>
            <header slot="header" class="wa-heading-m ">Number of GPU devices for all clusters</header>
            <div id="visualization-cluster-gpu-devices" class=""></div>
          </wa-card>
        </div>
        <wa-card with-header>
          <header slot="header" class="wa-heading-m ">Number of GPU devices per cluster</header>
          <div id="visualization-cluster-gpu-devices-by-cluster" class="wa-grid "></div>
        </wa-card>
        <wa-card with-header>
          <header slot="header" class="wa-heading-m ">GPU Nodes in not ready state</header>
          <div id="visualization-gpu-nodes-not-ready" class="wa-grid "></div>
        </wa-card>
      </div>
      <wa-card with-header>
        <header slot="header" class="wa-heading-m ">Number of GPU devices per node</header>
        <div id="visualization-cluster-gpu-devices-by-node" class="wa-grid "></div>
      </wa-card>
    </div>
  </div>
</wa-details>
{% endif %}
{{ super() }}
{%- endblock htmBodyEndClusterPage %}
{%- block htmStyleClusterPage %}
#visualization-cluster-memory-bytes-total, #visualization-cluster-cpu-bytes-total, #visualization-cluster-gpu-nodes, #visualization-cluster-gpu-devices {
  wa-avatar {
    --size: 2em;
  }
}
#observability-dashboard {
  .pill {
    border-radius: var(--wa-border-radius-pill);
    &:not(:active) {
      box-shadow: var(--wa-theme-glossy-inner-shine), var(--wa-theme-glossy-top-highlight), inset 0 -.4rem 0 0 rgba(255, 255, 255, 0.1), var(--wa-theme-glossy-lower-shade), var(--wa-theme-glossy-bottom-shadow);
      &:hover {
      background-color: var(--background-color-hover, var(--background-color));
        border-color: var(--border-color-hover, var(--border-color, var(--background-color-hover)));
        color: var(--text-color-hover, var(--text-color));
      }
    }
  }
}
{%- endblock htmStyleClusterPage %}
{%- block htmScriptInitClusterPage %}

      var facetRangeGapVal = document.querySelector("#pageSearchVal-pageFacetRangeGap-Cluster-input").value;
      var start = '{{ formatZonedDateTime(defaultRangeStart, "yyyy-MM-dd'T'HH:mm:ss.SSSX", defaultLocaleId, 'UTC') }}';
      var end = '{{ formatZonedDateTime(defaultRangeEnd, "yyyy-MM-dd'T'HH:mm:ss.SSSX", defaultLocaleId, 'UTC') }}';
      var step;
      switch (facetRangeGapVal) {
        case "+1YEAR":
          step = "1y";
          break;
        case "+1MONTH":
          step = "1M";
          break;
        case "+1DAY":
          step = "1d";
          break;
        case "+1HOUR":
          step = "1h";
          break;
        case "+1MINUTE":
          step = "1m";
          break;
        default:
          dayType = "Weekend";
      }

      var timeQuery = {
        start: start
        , end: end
        , step: step
      };

      Promise.all([
          queryMemoryBytesTotal(timeQuery)
          , queryCpuBytesTotal(timeQuery)
          , queryGpuNodesTotal(timeQuery)
          , queryGpuDevicesTotal(timeQuery)
          , queryGpuDevicesByCluster(timeQuery)
          , queryGpuDevicesByNode(timeQuery)
          , queryGpuNodesNotReady(timeQuery)
          , queryGpuUtilization(timeQuery)
          ]);
{%- endblock htmScriptInitClusterPage %}
{%- block htmScriptsClusterPage %}
{{ super() }}
  <script>

    async function queryMemoryBytesTotal(timeQuery) {
      const urls = [];
      if(window.varsFq.hubId.facetField) {
        const hubIds = Object.keys(window.varsFq.hubId.facetField.counts);
        hubIds.forEach((hubId, i) => {
          urls.push('/prom-keycloak-proxy/' + encodeURIComponent(hubId) + '/api/v1/query_range?' + new URLSearchParams(Object.assign({ 
              query: 'cluster:memory_usage_bytes:sum / on(cluster) cluster:capacity_memory_bytes:sum{label_node_role_kubernetes_io!="master"}' 
              }, timeQuery)).toString());
        });
        const responses = await Promise.all(urls.map(url => fetch(url)));
        const dataPromises = responses.map(response => response.json());
        const responseJsons = await Promise.all(dataPromises);
        var end = new Date();
        var start = new Date(new Date().setHours(end.getHours() - 1));

        var panelId = 'visualization-cluster-memory-bytes';
        var traces = [];
        responseJsons.forEach((responseJson, i) => {
          responseJson.data.result.forEach((result, j) => {
            var hubId = hubIds[i];
            traces.push({
              x: result.values.map(values => new Date(values[0] * 1000))
              , y: result.values.map(values => parseFloat(values[1]))
              , mode: 'scatter'
              , name: result.metric.cluster + ' in ' + hubId
              , text: result.values.map(values => '<a href="/en-us/edit/cluster/' + result.metric.cluster + '">' + hubId + ' ' + result.metric.cluster + '</a>')
            });
          });
        });

        var layout = {
          xaxis: {
            title: 'Time in {{ defaultZoneId }}'
          }
          , yaxis: {
            title: 'Percent of total memory usage'
            , tickformat: '.0%'
          }
          , legend: {
            title: {
              text: 'Clusters'
            }
          }
        };
        Plotly.newPlot(panelId, traces, layout);
      }
    }

    async function queryCpuBytesTotal(timeQuery) {
      const urls = [];
      if(window.varsFq.hubId.facetField) {
        const hubIds = Object.keys(window.varsFq.hubId.facetField.counts);
        hubIds.forEach((hubId, i) => {
          urls.push('/prom-keycloak-proxy/' + encodeURIComponent(hubId) + '/api/v1/query_range?' + new URLSearchParams(Object.assign({ 
              query: 'cluster:cpu_usage_cores:sum / on(cluster) cluster:capacity_cpu_cores:sum{label_node_role_kubernetes_io!="master"}' 
              }, timeQuery)).toString());
        });
        const responses = await Promise.all(urls.map(url => fetch(url)));
        const dataPromises = responses.map(response => response.json());
        const responseJsons = await Promise.all(dataPromises);
        var end = new Date();
        var start = new Date(new Date().setHours(end.getHours() - 1));

        var panelId = 'visualization-cluster-cpu-bytes';
        var traces = [];
        responseJsons.forEach((responseJson, i) => {
          responseJson.data.result.forEach((result, j) => {
            var hubId = hubIds[i];
            traces.push({
              x: result.values.map(values => new Date(values[0] * 1000))
              , y: result.values.map(values => parseFloat(values[1]))
              , mode: 'scatter'
              , name: result.metric.cluster + ' in ' + hubId
              , text: result.values.map(values => '<a href="/en-us/edit/cluster/' + result.metric.cluster + '">' + hubId + ' ' + result.metric.cluster + '</a>')
            });
          });
        });

        var layout = {
          xaxis: {
            title: 'Time in {{ defaultZoneId }}'
          }
          , yaxis: {
            title: 'Percent of total CPU usage'
            , tickformat: '.0%'
          }
          , legend: {
            title: {
              text: 'Clusters'
            }
          }
        };
        Plotly.newPlot(panelId, traces, layout);
      }
    }

    async function queryGpuUtilization(timeQuery) {
      const urls = [];
      if(window.varsFq.hubId.facetField) {
        const hubIds = Object.keys(window.varsFq.hubId.facetField.counts);
        hubIds.forEach((hubId, i) => {
          urls.push('/prom-keycloak-proxy/' + encodeURIComponent(hubId) + '/api/v1/query_range?' + new URLSearchParams(Object.assign({ query: 'sum(DCGM_FI_DEV_GPU_UTIL) by (cluster)' }, timeQuery)).toString());
        });
        const responses = await Promise.all(urls.map(url => fetch(url)));
        const dataPromises = responses.map(response => response.json());
        const responseJsons = await Promise.all(dataPromises);
        var end = new Date();
        var start = new Date(new Date().setHours(end.getHours() - 1));

        var panelId = 'visualization-cluster-gpu-utilization';
        var traces = [];
        responseJsons.forEach((responseJson, i) => {
          responseJson.data.result.forEach((result, j) => {
            var hubId = hubIds[i];
            traces.push({
              x: result.values.map(values => new Date(values[0] * 1000))
              , y: result.values.map(values => parseFloat(values[1]))
              , mode: 'lines'
              , name: result.metric.cluster + ' in ' + hubId
              , text: result.values.map(values => '<a href="/en-us/edit/cluster/' + result.metric.cluster + '">' + hubId + ' ' + result.metric.cluster + '</a>')
            });
          });
        });

        var layout = {
        };
        Plotly.newPlot(panelId, traces, layout);
      }
    }

    async function queryGpuNodesTotal(timeQuery) {
      const urls = [];
      if(window.varsFq.hubId.facetField) {
        const hubIds = Object.keys(window.varsFq.hubId.facetField.counts);
        hubIds.forEach((hubId, i) => {
          urls.push('/prom-keycloak-proxy/' + encodeURIComponent(hubId) + '/api/v1/query?' + new URLSearchParams(Object.assign({ 
              query: 'sum(gpu_operator_gpu_nodes_total)' 
              }, timeQuery)).toString());
        });
        const responses = await Promise.all(urls.map(url => fetch(url)));
        const dataPromises = responses.map(response => response.json());
        const responseJsons = await Promise.all(dataPromises);

        const totalSum = parseInt(responseJsons.reduce((accumulator, responseJson) => {
          return accumulator + (responseJson.data.result.length > 0 ? parseInt(responseJson.data.result[0].value[1]) : 0);
        }, 0));

        var avatar = document.createElement('wa-avatar');
        avatar.setAttribute('initials', totalSum)
        avatar.setAttribute('class', 'wa-accent wa-brand wa-heading-3xl ');
        avatar.setAttribute('slot', 'icon');
        document.querySelector('#visualization-cluster-gpu-nodes').append(avatar);
      }
    }

    async function queryGpuDevicesTotal(timeQuery) {
      const urls = [];
      if(window.varsFq.hubId.facetField) {
        const hubIds = Object.keys(window.varsFq.hubId.facetField.counts);
        hubIds.forEach((hubId, i) => {
          urls.push('/prom-keycloak-proxy/' + encodeURIComponent(hubId) + '/api/v1/query?' + new URLSearchParams(Object.assign({ 
              query: 'sum(gpu_operator_node_device_plugin_devices_total)' 
              }, timeQuery)).toString());
        });
        const responses = await Promise.all(urls.map(url => fetch(url)));
        const dataPromises = responses.map(response => response.json());
        const responseJsons = await Promise.all(dataPromises);

        const totalSum = parseInt(responseJsons.reduce((accumulator, responseJson) => {
          return accumulator + (responseJson.data.result.length > 0 ? parseInt(responseJson.data.result[0].value[1]) : 0);
        }, 0));

        var avatar = document.createElement('wa-avatar');
        avatar.setAttribute('initials', totalSum)
        avatar.setAttribute('class', 'wa-accent wa-brand wa-heading-3xl ');
        avatar.setAttribute('slot', 'icon');
        document.querySelector('#visualization-cluster-gpu-devices').append(avatar);
      }
    }

    async function queryGpuDevicesByCluster(timeQuery) {
      const urls = [];
      if(window.varsFq.hubId.facetField) {
        const hubIds = Object.keys(window.varsFq.hubId.facetField.counts);
        hubIds.forEach((hubId, i) => {
          urls.push('/prom-keycloak-proxy/' + encodeURIComponent(hubId) + '/api/v1/query?' + new URLSearchParams(Object.assign({ 
              query: 'sum(gpu_operator_node_device_plugin_devices_total) by (cluster)' 
              }, timeQuery)).toString());
        });
        const responses = await Promise.all(urls.map(url => fetch(url)));
        const dataPromises = responses.map(response => response.json());
        const responseJsons = await Promise.all(dataPromises);
        const panelId = 'visualization-cluster-gpu-devices-by-cluster';

        responseJsons.forEach((responseJson, i) => {
          responseJson.data.result.forEach((result, j) => {
            var hubId = hubIds[i];
            var clusterName = result.metric.cluster + ' in ' + hubId;
            var clusterId = 'HUB-' + hubId + '-CLUSTER-' + result.metric.cluster;
            var elemId = 'visualization-cluster-gpu-devices-by-cluster-' + clusterId;

            var a = document.createElement('a');
            a.setAttribute('href', '/en-us/edit/cluster/' + clusterId);
            document.querySelector('#' + panelId).append(a);

            var callout = document.createElement('wa-callout');
            callout.setAttribute('id', elemId);
            callout.setAttribute('appearance', 'outlined');
            callout.setAttribute('variant', 'neutral');
            callout.setAttribute('class', 'pill');
            a.append(callout);

            var avatar = document.createElement('wa-avatar');
            avatar.setAttribute('initials', result.value[1])
            avatar.setAttribute('class', 'wa-accent wa-brand ');
            avatar.setAttribute('slot', 'icon');
            callout.append(avatar);

            var stack = document.createElement('div');
            stack.setAttribute('class', 'wa-stack wa-gap-s ')
            callout.append(stack);

            var elem0 = document.createElement('div');
            elem0.innerText = clusterName;
            stack.append(elem0);
          });
        });
      }
    }

    async function queryGpuDevicesByNode(timeQuery) {
      const urls = [];
      if(window.varsFq.hubId.facetField) {
        const hubIds = Object.keys(window.varsFq.hubId.facetField.counts);
        hubIds.forEach((hubId, i) => {
          urls.push('/prom-keycloak-proxy/' + encodeURIComponent(hubId) + '/api/v1/query?' + new URLSearchParams(Object.assign({ 
              query: 'sum(gpu_operator_node_device_plugin_devices_total) by (cluster, node)' 
              }, timeQuery)).toString());
        });
        const responses = await Promise.all(urls.map(url => fetch(url)));
        const dataPromises = responses.map(response => response.json());
        const responseJsons = await Promise.all(dataPromises);
        const panelId = 'visualization-cluster-gpu-devices-by-node';

        responseJsons.forEach((responseJson, i) => {
          responseJson.data.result.forEach((result, j) => {
            var hubId = hubIds[i];
            var clusterName = result.metric.cluster + ' in ' + hubId;
            var clusterId = 'HUB-' + hubId + '-CLUSTER-' + result.metric.cluster;
            var nodeId = 'HUB-' + hubId + '-CLUSTER-' + result.metric.cluster + '-NODE-' + result.metric.node;
            var elemId = 'visualization-cluster-gpu-devices-by-node-' + clusterId + '-' + result.metric.node;

            var a = document.createElement('a');
            a.setAttribute('href', '/en-us/edit/ai-node/' + nodeId);
            document.querySelector('#' + panelId).append(a);

            var callout = document.createElement('wa-callout');
            callout.setAttribute('id', elemId);
            callout.setAttribute('appearance', 'outlined');
            callout.setAttribute('variant', 'neutral');
            callout.setAttribute('class', 'pill');
            a.append(callout);

            var avatar = document.createElement('wa-avatar');
            avatar.setAttribute('initials', result.value[1])
            avatar.setAttribute('class', 'wa-accent wa-brand ');
            avatar.setAttribute('slot', 'icon');
            callout.append(avatar);

            var stack = document.createElement('div');
            stack.setAttribute('class', 'wa-stack wa-gap-0 ')
            callout.append(stack);

            var elem0 = document.createElement('div');
            elem0.innerText = clusterName;
            stack.append(elem0);

            var elem1 = document.createElement('div');
            elem1.innerText = result.metric.node;
            stack.append(elem1);
          });
        });
      }
    }

    async function queryGpuNodesNotReady(timeQuery) {
      const urls = [];
      if(window.varsFq.hubId.facetField) {
        const hubIds = Object.keys(window.varsFq.hubId.facetField.counts);
        hubIds.forEach((hubId, i) => {
          urls.push('/prom-keycloak-proxy/' + encodeURIComponent(hubId) + '/api/v1/query?' + new URLSearchParams(Object.assign({ 
              query: 'kube_node_status_condition{status="unknown", condition="Ready"} * on (cluster, node) group_left(label_nvidia_com_gpu_present) kube_node_labels{label_nvidia_com_gpu_present="true"} == 1' 
              }, timeQuery)).toString());
        });
        const responses = await Promise.all(urls.map(url => fetch(url)));
        const dataPromises = responses.map(response => response.json());
        const responseJsons = await Promise.all(dataPromises);
        const panelId = 'visualization-gpu-nodes-not-ready';

        responseJsons.forEach((responseJson, i) => {
          responseJson.data.result.forEach((result, j) => {
            var hubId = hubIds[i];
            var clusterName = result.metric.cluster + ' in ' + hubId;
            var clusterId = 'HUB-' + hubId + '-CLUSTER-' + result.metric.cluster;
            var nodeId = 'HUB-' + hubId + '-CLUSTER-' + result.metric.cluster + '-NODE-' + result.metric.node;
            var elemId = 'visualization-gpu-nodes-not-ready-' + clusterId + '-' + result.metric.node;

            var a = document.createElement('a');
            a.setAttribute('href', '/en-us/edit/ai-node/' + nodeId);
            document.querySelector('#' + panelId).append(a);

            var callout = document.createElement('wa-callout');
            callout.setAttribute('id', elemId);
            callout.setAttribute('appearance', 'accent outlined');
            callout.setAttribute('variant', 'danger');
            callout.setAttribute('class', 'pill');
            a.append(callout);

            var icon = document.createElement('wa-icon');
            icon.setAttribute('slot', 'icon')
            icon.setAttribute('name', 'triangle-exclamation')
            icon.setAttribute('variant', 'solid')
            callout.append(icon);

            var stack = document.createElement('div');
            stack.setAttribute('class', 'wa-stack wa-gap-s ')
            callout.append(stack);

            var elem0 = document.createElement('div');
            elem0.innerText = clusterName;
            stack.append(elem0);

            var elem1 = document.createElement('div');
            elem1.innerText = result.metric.node;
            stack.append(elem1);
          });
        });
      }
    }
  </script>
{%- endblock htmScriptsClusterPage %}
